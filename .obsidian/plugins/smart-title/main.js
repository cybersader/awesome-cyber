/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => SmartTitlePlugin
});
module.exports = __toCommonJS(main_exports);

// src/settings.ts
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  tagSeparators: "\uFF5C",
  remainingAsAlias: true
};
var SmartTitleSettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Advanced Settings" });
    new import_obsidian.Setting(containerEl).setName("Tag separators to split title").setDesc("The tag separator will split title to 'tag & remaining', multiple separators split with '|'.").addText((textComponent) => {
      textComponent.inputEl.required = true;
      textComponent.inputEl.addEventListener("blur", () => {
        textComponent.inputEl.reportValidity();
      });
      textComponent.setValue(this.plugin.settings.tagSeparators).onChange(async (value) => {
        if (textComponent.inputEl.reportValidity()) {
          this.plugin.settings.tagSeparators = value;
          await this.plugin.saveSettings();
        }
      });
    });
    new import_obsidian.Setting(containerEl).setName("Remaing as alias").setDesc("Whether the remaining part be used as an alias.").addToggle((togleComponent) => {
      togleComponent.setValue(this.plugin.settings.remainingAsAlias).onChange(async (value) => {
        this.plugin.settings.remainingAsAlias = value;
        await this.plugin.saveSettings();
      });
    });
  }
};

// src/index.ts
var import_obsidian2 = require("obsidian");
var TAG_SEPARATORS_SEPARATOR = "|";
var SmartTitlePlugin = class extends import_obsidian2.Plugin {
  async onload() {
    await this.loadSettings();
    this.registerEvent(this.app.workspace.on("editor-change", (editor, info) => {
      if (info.file) {
        this.smartTitle(info.file);
      }
    }));
    this.addSettingTab(new SmartTitleSettingsTab(this.app, this));
  }
  // loading settings from disk or default
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  // save setting to disk
  async saveSettings() {
    await this.saveData(this.settings);
  }
  // main logic. extract tags and aliases from the title.
  async smartTitle(currentFile) {
    const currentTitle = currentFile.basename;
    if (this.settings.tagSeparators && this.settings.tagSeparators.length > 0) {
      const separatorsArray = this.settings.tagSeparators.split(TAG_SEPARATORS_SEPARATOR);
      for (const separator of separatorsArray) {
        const index = currentTitle.indexOf(separator);
        if (index > 0 && index < currentTitle.length - 1) {
          const tag = currentTitle.slice(0, index);
          const remaining = currentTitle.slice(index + 1);
          this.addTagAndAlias(currentFile, tag, remaining, this.settings.remainingAsAlias);
          break;
        }
      }
    }
  }
  // add tags & alias
  async addTagAndAlias(currentFile, tag, remaining, remainingAsAlias) {
    await this.app.fileManager.processFrontMatter(currentFile, (frontMatter) => {
      const tags = [...frontMatter.tags || []];
      const aliases = [...frontMatter.aliases || []];
      if (tag && tag.length > 0 && /[^0-9#\s]/g.test(tag) && !tags.includes(tag)) {
        tags.push(tag);
        frontMatter.tags = tags;
      }
      if (remainingAsAlias && remaining && remaining.length > 0 && !aliases.includes(remaining)) {
        aliases.push(remaining);
        frontMatter.aliases = aliases;
      }
    });
  }
};
