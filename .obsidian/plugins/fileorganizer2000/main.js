/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  default: () => FileOrganizer
});
module.exports = __toCommonJS(src_exports);
var import_obsidian7 = require("obsidian");

// src/modules/name.ts
var import_obsidian = require("obsidian");

// utils.ts
function formatToSafeName(format) {
  return format.replace(/[\\/:"]/g, "");
}
function cleanPath(path) {
  const trimmedPath = path.trim();
  const pathWithoutLeadingAndTrailingSlashes = trimmedPath.replace(
    /^\/+|\/+$/g,
    ""
  );
  return pathWithoutLeadingAndTrailingSlashes;
}
var logMessage = (...args) => {
  if (true) {
    return;
  }
  console.log(...args);
};

// src/modules/name.ts
async function useName(document, { baseUrl, apiKey }) {
  const data = {
    messages: [
      {
        role: "system",
        content: "You are a helpful assistant. You only answer short (less than 30 chars titles). You do not use any special character just text. Use something very specific to the content not a generic title."
      },
      {
        role: "user",
        content: "Give a title to this document: \n " + document
      }
    ]
  };
  const endpoint = "api/name";
  const url = `${baseUrl}/${endpoint}`;
  const response = await (0, import_obsidian.requestUrl)({
    url,
    method: "POST",
    body: JSON.stringify(data),
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${apiKey}`
    }
  });
  const result = await response.json;
  logMessage(result.choices[0].message.content);
  return result.choices[0].message.content.trim();
}
var name_default = useName;

// src/modules/vision.ts
var import_obsidian2 = require("obsidian");
var defaultPrompt = `Extract text from image. Write in markdown. If there's a drawing, describe it.`;
async function useVision(encodedImage, systemPrompt = defaultPrompt, { baseUrl, apiKey }) {
  const jsonPayload = {
    max_tokens: 800,
    messages: [
      {
        role: "user",
        content: [
          {
            type: "text",
            text: systemPrompt
          },
          {
            type: "image_url",
            image_url: {
              url: `data:image/jpeg;base64,${encodedImage}`
            }
          }
        ]
      }
    ]
  };
  const endpoint = "api/vision";
  const sanitizedBaseUrl = baseUrl.endsWith("/") ? baseUrl.slice(0, -1) : baseUrl;
  const url = `${sanitizedBaseUrl}/${endpoint}`;
  const response = await (0, import_obsidian2.requestUrl)({
    url,
    method: "POST",
    body: JSON.stringify(jsonPayload),
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${apiKey}`
    }
  });
  const result = await response.json;
  return result.choices[0].message.content;
}
var vision_default = useVision;

// src/modules/audio.ts
var import_obsidian3 = require("obsidian");
async function useAudio(audioFileBase64, { baseUrl, apiKey }) {
  const endpoint = "api/audio";
  const url = `${baseUrl}/${endpoint}`;
  try {
    const result = await (0, import_obsidian3.requestUrl)({
      url,
      method: "POST",
      body: JSON.stringify({ file: audioFileBase64 }),
      headers: {
        Authorization: "Bearer " + apiKey,
        "Content-Type": "application/json"
      }
    });
    const data = await result.json;
    logMessage(data.text);
    return data.text;
  } catch (error) {
    console.error("Error uploading audio file:", error);
  }
}
var audio_default = useAudio;

// src/modules/text.ts
var import_obsidian4 = require("obsidian");
async function useText(content, systemPrompt, { baseUrl, apiKey }) {
  const data = {
    temperature: 0,
    messages: [
      {
        role: "system",
        content: systemPrompt
      },
      {
        role: "user",
        content
      }
    ]
  };
  const endpoint = "api/text";
  const url = `${baseUrl}/${endpoint}`;
  const response = await (0, import_obsidian4.requestUrl)({
    url,
    method: "POST",
    body: JSON.stringify(data),
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${apiKey}`
    }
  });
  const result = await response.json;
  logMessage(result);
  logMessage(result.choices[0].message.content);
  return result.choices[0].message.content.trim();
}
var text_default = useText;

// src/FileOrganizerSettingTab.ts
var import_obsidian5 = require("obsidian");
var FileOrganizerSettingTab = class extends import_obsidian5.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  async sendSecretApiRequest(jsonPayload) {
    const url = `${this.plugin.settings.defaultServerUrl}/api/secret`;
    try {
      const response = await (0, import_obsidian5.requestUrl)({
        url,
        method: "POST",
        body: JSON.stringify(jsonPayload),
        headers: {
          Authorization: `Bearer ${this.plugin.settings.API_KEY}`,
          "Content-Type": "application/json"
        }
      });
      return response;
    } catch (error) {
      console.error("Error sending secret API request:", error);
      throw error;
    }
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    const apiKeySetting = new import_obsidian5.Setting(containerEl).setName("File Organizer API Key").setDesc(
      "Enter your API Key here. Get it at https://app.fileorganizer2000.com/ "
    ).addText(
      (text) => text.setPlaceholder("Enter your API Key").setValue(this.plugin.settings.API_KEY).onChange(async (value) => {
        if (value)
          loginButton.settingEl.hide();
        if (!value)
          loginButton.settingEl.show();
        this.plugin.settings.API_KEY = value;
        await this.plugin.saveSettings();
      })
    );
    const loginButton = new import_obsidian5.Setting(containerEl).setName("Login").setDesc("Click to login to File Organizer 2000").addButton(
      (button) => button.setButtonText("Login").onClick(() => {
        window.open("https://app.fileorganizer2000.com/", "_blank");
      })
    );
    loginButton.settingEl.hide();
    new import_obsidian5.Setting(containerEl).setName("Inbox folder").setDesc("Choose which folder to automatically organize files from").addText(
      (text) => text.setPlaceholder("Enter your path").setValue(this.plugin.settings.pathToWatch).onChange(async (value) => {
        this.plugin.settings.pathToWatch = cleanPath(value);
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian5.Setting(containerEl).setName("Features").setHeading();
    new import_obsidian5.Setting(containerEl).setName("FileOrganizer logs").setDesc(
      "Allows you to keep track of the changes made by file Organizer."
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.useLogs).onChange(async (value) => {
        this.plugin.settings.useLogs = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian5.Setting(containerEl).setName("Similar tags").setDesc("Append similar tags to processed files.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.useSimilarTags).onChange(async (value) => {
        this.plugin.settings.useSimilarTags = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian5.Setting(containerEl).setName("Add similar tags in frontmatter").setDesc("Use frontmatter to add similar tags to processed files.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.useSimilarTagsInFrontmatter).onChange(async (value) => {
        this.plugin.settings.useSimilarTagsInFrontmatter = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian5.Setting(containerEl).setName("Rename document title").setDesc("Rename the document title based on the content.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.renameDocumentTitle).onChange(async (value) => {
        this.plugin.settings.renameDocumentTitle = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian5.Setting(containerEl).setName("Aliases").setDesc("Append aliases to processed files.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.useAliases).onChange(async (value) => {
        this.plugin.settings.useAliases = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian5.Setting(containerEl).setName("Processed File Tag").setDesc("Specify the tag to be added to processed files.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.processedTag).onChange(async (value) => {
        this.plugin.settings.processedTag = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian5.Setting(containerEl).setName("Folder config").setHeading();
    new import_obsidian5.Setting(containerEl).setName("Attachments folder").setDesc(
      "Enter the path to the folder where the original images and audio will be moved."
    ).addText(
      (text) => text.setPlaceholder("Enter your path").setValue(this.plugin.settings.attachmentsPath).onChange(async (value) => {
        this.plugin.settings.attachmentsPath = cleanPath(value);
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian5.Setting(containerEl).setName("File Organizer log folder").setDesc("Choose a folder for Organization Logs e.g. Ava/Logs.").addText(
      (text) => text.setPlaceholder("Enter your path").setValue(this.plugin.settings.logFolderPath).onChange(async (value) => {
        this.plugin.settings.logFolderPath = cleanPath(value);
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian5.Setting(containerEl).setName("Output folder path").setDesc(
      "Enter the path where you want to save the processed files. e.g. Processed/myfavoritefolder"
    ).addText(
      (text) => text.setPlaceholder("Enter your path").setValue(this.plugin.settings.defaultDestinationPath).onChange(async (value) => {
        const cleanedPath = cleanPath(value);
        logMessage(cleanedPath);
        this.plugin.settings.defaultDestinationPath = cleanedPath;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian5.Setting(containerEl).setName("Experimental features").setHeading();
    new import_obsidian5.Setting(containerEl).setName("Early access features").setDesc(
      "Activate early access features. Go to https://dub.sh/2000 to support."
    ).addText(
      (text) => text.setPlaceholder("Enter access code for Early Access Features").setValue(this.plugin.settings.earlyAccessCode).onChange(async (value) => {
        if (value.length !== 8) {
          return;
        }
        const jsonPayload = {
          code: value
        };
        try {
          const url = `${this.plugin.settings.defaultServerUrl}/api/secret`;
          const response = await (0, import_obsidian5.requestUrl)({
            url,
            method: "POST",
            body: JSON.stringify(jsonPayload),
            headers: {
              Authorization: `Bearer ${this.plugin.settings.API_KEY}`,
              "Content-Type": "application/json"
            }
          });
          logMessage(response);
          if (response.status !== 200) {
            new import_obsidian5.Notice("Failed to activate Early Access Features.");
            return;
          }
          this.plugin.settings.earlyAccessCode = value;
          this.plugin.settings.enableEarlyAccess = true;
          await this.plugin.saveSettings();
          new import_obsidian5.Notice("Early Access Features Activated Successfully");
        } catch (error) {
          console.error("Error activating Early Access Features:", error);
          new import_obsidian5.Notice("Error during activation process.");
        }
      })
    );
    new import_obsidian5.Setting(containerEl).setName("Use Self-hosted").setDesc("Toggle to use a custom server instead of the default.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.useCustomServer).onChange(async (value) => {
        this.plugin.settings.useCustomServer = value;
        await this.plugin.saveSettings();
        if (!value) {
          customServerSetting.settingEl.hide();
          this.plugin.settings.enableEarlyAccess = false;
          return;
        }
        customServerSetting.settingEl.show();
        this.plugin.settings.enableEarlyAccess = true;
      })
    );
    const customServerSetting = new import_obsidian5.Setting(containerEl).setName("Self-hosted URL").setDesc("Enter the address of your custom server.").addText(
      (text) => text.setPlaceholder("http://localhost:3000").setValue(this.plugin.settings.customServerUrl).onChange(async (value) => {
        this.plugin.settings.customServerUrl = value;
        await this.plugin.saveSettings();
      })
    );
    customServerSetting.settingEl.hide();
    if (this.plugin.settings.useCustomServer) {
      customServerSetting.settingEl.show();
    }
    if (!this.plugin.settings.API_KEY) {
      loginButton.settingEl.show();
    }
    new import_obsidian5.Setting(containerEl).setName("Custom vision prompt").setDesc("Enter your custom prompt for vision processing here").addText(
      (text) => text.setPlaceholder("Enter your custom prompt").setValue(this.plugin.settings.customVisionPrompt).onChange(async (value) => {
        this.plugin.settings.customVisionPrompt = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian5.Setting(containerEl).setName("AI Assistant (available in early access)").setDesc("A sidebar that gives you more control in your file management.");
    new import_obsidian5.Setting(containerEl).setName("Experimental: Describe workflow (in progress)").setDesc(
      "Use words to explain how File Organizer uses GPT-4 to organize your files."
    ).setDisabled(true);
    new import_obsidian5.Setting(containerEl).setName("Experimental: Full Auto Org (in progress)").setDesc("Let file Organizer work fully automatically.").setDisabled(true);
  }
};

// src/AssistantView.ts
var import_obsidian6 = require("obsidian");
var ASSISTANT_VIEW_TYPE = "fo2k.assistant.sidebar";
var AssistantView = class extends import_obsidian6.ItemView {
  // Added for rename suggestion
  constructor(leaf, plugin) {
    super(leaf);
    this.suggestLinks = async (file, content) => {
      const links = await this.plugin.getMostSimilarFileByName(content, file);
      this.similarLinkBox.empty();
      const child = this.similarLinkBox.createEl("a", { text: links.basename });
      child.onclick = () => {
        this.app.workspace.openLinkText(links.path, "", true);
      };
      this.similarLinkBox.appendChild(child);
    };
    this.suggestTags = async (file, content) => {
      const tags = await this.plugin.getSimilarTags(content, file.basename);
      if (tags.length > 0) {
        this.suggestionBox.empty();
        tags.forEach((tag) => {
          const child = this.suggestionBox.appendChild(
            this.suggestionBox.createEl("span", {
              cls: [
                "cursor-pointer",
                "cm-hashtag",
                "cm-hashtag-begin",
                "cm-meta",
                "cm-tag",
                "cm-hashtag-end"
              ],
              text: tag
            })
          );
          child.style.cursor = "pointer";
          child.style.margin = "2px";
          child.addEventListener("click", () => {
            if (!tag.startsWith("#")) {
              tag = `#${tag}`;
            }
            this.plugin.appendTag(file, tag);
            child.remove();
          });
        });
      } else {
        this.suggestionBox.setText("No suggestions");
      }
      this.loading.style.display = "none";
    };
    this.suggestAlias = async (file, content) => {
      const suggestedName = await this.plugin.generateNameFromContent(content);
      this.aliasSuggestionBox.empty();
      this.aliasSuggestionBox.style.display = "flex";
      this.aliasSuggestionBox.style.alignItems = "center";
      const nameElement = this.aliasSuggestionBox.createEl("span", {
        text: suggestedName
      });
      const renameIcon = this.aliasSuggestionBox.createEl("span", {
        cls: ["clickable-icon", "setting-editor-extra-setting-button"]
      });
      (0, import_obsidian6.setIcon)(renameIcon, "plus");
      renameIcon.onclick = async () => {
        logMessage("Adding alias " + suggestedName + " to " + file.basename);
        this.plugin.appendToFrontMatter(file, "alias", suggestedName);
      };
      this.aliasSuggestionBox.appendChild(nameElement);
      this.aliasSuggestionBox.appendChild(renameIcon);
    };
    this.suggestFolders = async (file, content) => {
      const folder = await this.plugin.getAIClassifiedFolder(content, file);
      this.similarFolderBox.empty();
      this.similarFolderBox.style.display = "flex";
      this.similarFolderBox.style.alignItems = "center";
      this.similarFolderBox.appendChild(
        this.similarFolderBox.createEl("span", { text: folder })
      );
      const moveFilebutton = this.similarFolderBox.createEl("div", {
        text: "Move",
        cls: ["clickable-icon", "setting-editor-extra-setting-button"]
      });
      (0, import_obsidian6.setIcon)(moveFilebutton, "folder-input");
      moveFilebutton.style.cursor = "pointer";
      moveFilebutton.style.margin = "8px";
      moveFilebutton.onclick = () => {
        this.plugin.moveContent(file, file.basename, folder);
      };
      this.similarFolderBox.appendChild(moveFilebutton);
    };
    this.handleFileOpen = async (file) => {
      const content = await this.plugin.getTextFromFile(file);
      this.suggestTags(file, content);
      this.suggestLinks(file, content);
      this.suggestFolders(file, content);
      this.suggestAlias(file, content);
    };
    this.plugin = plugin;
  }
  getDisplayText() {
    return "Assistant";
  }
  getViewType() {
    return ASSISTANT_VIEW_TYPE;
  }
  getIcon() {
    return "pencil";
  }
  initUI() {
    this.containerEl.empty();
    this.containerEl.addClass("tag-container");
    if (!this.plugin.settings.enableEarlyAccess) {
      this.containerEl.createEl("h3", {
        text: "The AI Assistant is an early access feature currently available to supporters."
      });
      const supportLink = this.containerEl.createEl("a", {
        href: "https://dub.sh/support-fo2k",
        text: "Support here to gain access."
      });
      supportLink.setAttr("target", "_blank");
    }
    this.containerEl.createEl("h4", {
      text: "Similar tags",
      cls: ["tree-item-self"]
    });
    this.suggestionBox = this.containerEl.createEl("div");
    this.suggestionBox.style.paddingLeft = "24px";
    this.containerEl.createEl("h4", {
      text: "Most similar link",
      cls: ["tree-item-self"]
    });
    this.similarLinkBox = this.containerEl.createEl("div");
    this.similarLinkBox.style.paddingLeft = "24px";
    this.containerEl.createEl("h4", {
      text: "Most similar folder",
      cls: ["tree-item-self"]
    });
    this.similarFolderBox = this.containerEl.createEl("div");
    this.similarFolderBox.style.paddingLeft = "24px";
    this.containerEl.createEl("h4", {
      text: "Suggested Alias",
      cls: ["tree-item-self"]
    });
    this.aliasSuggestionBox = this.containerEl.createEl("div");
    this.aliasSuggestionBox.style.paddingLeft = "24px";
    this.loading = this.suggestionBox.createEl("div", {
      text: "Loading..."
    });
    this.loading.style.display = "none";
  }
  async onOpen() {
    this.containerEl.empty();
    this.containerEl.addClass("tag-container");
    this.initUI();
    this.registerEvent(
      this.app.workspace.on("file-open", async (file) => {
        if (!this.plugin.settings.enableEarlyAccess) {
          return;
        }
        this.loading.style.display = "block";
        if (!file) {
          this.suggestionBox.setText("No file opened");
          this.loading.style.display = "none";
          return;
        }
        this.handleFileOpen(file);
      })
    );
  }
  async onClose() {
  }
};

// src/index.ts
var FileOrganizerSettings = class {
  constructor() {
    this.API_KEY = "";
    this.useLogs = true;
    this.defaultDestinationPath = "_FileOrganizer2000/Processed";
    this.attachmentsPath = "_FileOrganizer2000/Processed/Attachments";
    this.pathToWatch = "_FileOrganizer2000/Inbox";
    this.logFolderPath = "_FileOrganizer2000/Logs";
    this.useSimilarTags = true;
    // default value is true
    this.renameDocumentTitle = true;
    // default value is true
    this.useAliases = false;
    // default value is false
    this.customVisionPrompt = "";
    // default value is an empty string
    this.useAutoAppend = false;
    this.defaultServerUrl = "https://app.fileorganizer2000.com";
    this.customServerUrl = "https://file-organizer-2000.vercel.app/";
    this.useCustomServer = false;
    this.useSimilarTagsInFrontmatter = false;
    this.enableEarlyAccess = false;
    this.earlyAccessCode = "";
    this.processedTag = false;
  }
};
var validAudioExtensions = ["mp3", "wav", "webm", "m4a"];
var validImageExtensions = ["png", "jpg", "jpeg", "gif", "svg", "webp"];
var validMediaExtensions = [...validAudioExtensions, ...validImageExtensions];
var validTextExtensions = ["md", "txt"];
var validExtensions = [...validMediaExtensions, ...validTextExtensions];
var isValidExtension = (extension) => {
  if (!validExtensions.includes(extension)) {
    new import_obsidian7.Notice("Sorry, FileOrganizer does not support this file type.");
    return false;
  }
  return true;
};
var FileOrganizer = class extends import_obsidian7.Plugin {
  // all files in inbox will go through this function
  async processFileV2(originalFile) {
    try {
      new import_obsidian7.Notice(`Looking at ${originalFile.basename}`, 3e3);
      this.validateAPIKey();
      if (!originalFile.extension || !isValidExtension(originalFile.extension))
        return;
      await this.checkAndCreateFolders();
      const text = await this.getTextFromFile(originalFile);
      const isRenameEnabled = this.settings.renameDocumentTitle;
      const humanReadableFileName = isRenameEnabled ? await this.generateNameFromContent(text) : originalFile.basename;
      if (validMediaExtensions.includes(originalFile.extension)) {
        const annotatedFile = await this.createFileFromContent(text);
        this.appendToCustomLogFile(
          `Generated annotation for [[${annotatedFile.basename}]]`
        );
        await this.moveToDefaultAttachmentFolder(
          originalFile,
          humanReadableFileName
        );
        await this.appendAttachment(annotatedFile, originalFile);
        await this.renameTagAndOrganize(
          annotatedFile,
          text,
          humanReadableFileName
        );
        await this.tagAsProcessed(annotatedFile);
      } else {
        await this.renameTagAndOrganize(
          originalFile,
          text,
          humanReadableFileName
        );
        await this.tagAsProcessed(originalFile);
      }
    } catch (e) {
      new import_obsidian7.Notice(
        `Error processing ${originalFile.basename}: ${e.message}`,
        3e3
      );
    }
  }
  // we use this to keep track if we have already processed a file vs not
  // to indicate it to our users (aka they won't need to send it to inbox again)
  async tagAsProcessed(file) {
    if (!this.settings.processedTag) {
      return;
    }
    const tag = "#fo2k";
    this.appendTag(file, tag);
  }
  // experimental meant to extend user capabilities
  async useCustomClassifier(content) {
    const classifications = [
      { type: "todos", moveTo: "/todos" },
      { type: "notes", moveTo: "/notes" },
      { type: "morning notes", moveTo: "/morning-notes" },
      { type: "reminder", moveTo: "/reminders" }
    ];
    const whatTypeOfDocument = await text_default(
      `Content:
				${content} 
				classifications:
				${classifications.join(",")},
				'", which of the following classifications would be the most appropriate?`,
      "Please respond with the name of the most appropriate classification from the provided list. If none of the classifications are suitable, respond with 'None'.",
      {
        baseUrl: this.settings.useCustomServer ? this.settings.customServerUrl : this.settings.defaultServerUrl,
        apiKey: this.settings.API_KEY
      }
    );
    logMessage("This is closest to the following", whatTypeOfDocument);
    return whatTypeOfDocument;
  }
  async organizeFile(file, content) {
    const destinationFolder = await this.getAIClassifiedFolder(content, file);
    await this.moveContent(file, file.basename, destinationFolder);
  }
  async renameTagAndOrganize(file, content, fileName) {
    const destinationFolder = await this.getAIClassifiedFolder(content, file);
    await this.appendAlias(file, file.basename);
    await this.moveContent(file, fileName, destinationFolder);
    await this.appendSimilarTags(content, file);
  }
  async createBackup(file) {
    const destinationFolder = this.settings.defaultDestinationPath;
    const destinationPath = `${destinationFolder}/${file.name}`;
    await this.app.vault.copy(file, destinationPath);
    this.appendToCustomLogFile(
      `Backed Up [[${file.name}]] to ${destinationPath}`
    );
  }
  async showAssistantSidebar() {
    this.app.workspace.detachLeavesOfType(ASSISTANT_VIEW_TYPE);
    await this.app.workspace.getRightLeaf(false).setViewState({
      type: ASSISTANT_VIEW_TYPE,
      active: true
    });
    this.app.workspace.revealLeaf(
      this.app.workspace.getLeavesOfType(ASSISTANT_VIEW_TYPE)[0]
    );
  }
  async getTextFromFile(file) {
    let content = "";
    if (file.extension === "md") {
      content = await this.app.vault.read(file);
    } else if (validImageExtensions.includes(file.extension)) {
      content = await this.generateImageAnnotation(file);
    } else if (validAudioExtensions.includes(file.extension)) {
      content = await this.generateTranscriptFromAudio(file);
    }
    return content;
  }
  // adds an attachment to a file using the ![[attachment]] syntax
  async appendAttachment(processedFile, attachmentFile) {
    logMessage("Appending attachment", attachmentFile);
    await this.app.vault.append(processedFile, `![[${attachmentFile.name}]]`);
  }
  async appendToFrontMatter(file, key, value) {
    await this.app.fileManager.processFrontMatter(file, (frontmatter) => {
      if (!frontmatter.hasOwnProperty(key)) {
        frontmatter[key] = value;
        return;
      }
      if (!Array.isArray(frontmatter[key])) {
        frontmatter[key] = [frontmatter[key]];
      }
      frontmatter[key].push(value);
    });
  }
  async appendAlias(file, alias) {
    if (!this.settings.useAliases) {
      logMessage("Not appending aliases");
      return;
    }
    logMessage("Appending alias", alias);
    this.appendToFrontMatter(file, "alias", alias);
  }
  // creates a .md file with a humean readable name guessed from the content
  async createFileFromContent(content) {
    const now = new Date();
    const formattedNow = now.toISOString().replace(/[-:.TZ]/g, "");
    let name = formattedNow;
    try {
      name = await name_default(content, {
        baseUrl: this.settings.useCustomServer ? this.settings.customServerUrl : this.settings.defaultServerUrl,
        apiKey: this.settings.API_KEY
      });
    } catch (error) {
      console.error("Error processing file:", error.status);
      new import_obsidian7.Notice("Could not set a human readable name.");
    }
    const safeName = formatToSafeName(name);
    const outputFilePath = `/${this.settings.defaultDestinationPath}/${safeName}.md`;
    const file = await this.app.vault.create(outputFilePath, content);
    return file;
  }
  async moveContent(file, humanReadableFileName, destinationFolder = "") {
    new import_obsidian7.Notice(`Moving file to ${destinationFolder}`, 3e3);
    await this.app.vault.rename(
      file,
      `${destinationFolder}/${humanReadableFileName}.${file.extension}`
    );
    await this.appendToCustomLogFile(
      `Organized [[${humanReadableFileName}]] into ${destinationFolder}`
    );
    return file;
  }
  async moveToDefaultAttachmentFolder(file, newFileName) {
    const destinationFolder = this.settings.attachmentsPath;
    const destinationPath = `${destinationFolder}/${newFileName}.${file.extension}`;
    await this.app.vault.rename(file, destinationPath);
    await this.appendToCustomLogFile(
      `Moved [[${newFileName}.${file.extension}]] to attachments`
    );
  }
  async generateNameFromContent(content) {
    new import_obsidian7.Notice(`Generating name for ${content.substring(0, 20)}...`, 3e3);
    const name = await name_default(content, {
      baseUrl: this.settings.useCustomServer ? this.settings.customServerUrl : this.settings.defaultServerUrl,
      apiKey: this.settings.API_KEY
    });
    const safeName = formatToSafeName(name);
    new import_obsidian7.Notice(`Generated name: ${safeName}`, 3e3);
    return safeName;
  }
  async generateTranscriptFromAudio(file) {
    new import_obsidian7.Notice(`Generating transcription for ${file.basename}`, 3e3);
    const arrayBuffer = await this.app.vault.readBinary(file);
    const fileContent = Buffer.from(arrayBuffer);
    const encodedAudio = fileContent.toString("base64");
    logMessage(`Encoded: ${encodedAudio.substring(0, 20)}...`);
    const transcribedText = await audio_default(encodedAudio, {
      baseUrl: this.settings.useCustomServer ? this.settings.customServerUrl : this.settings.defaultServerUrl,
      apiKey: this.settings.API_KEY
    });
    const postProcessedText = transcribedText;
    return postProcessedText;
  }
  async generateImageAnnotation(file, customPrompt) {
    new import_obsidian7.Notice(`Generating annotation for ${file.basename}`, 3e3);
    const arrayBuffer = await this.app.vault.readBinary(file);
    const fileContent = Buffer.from(arrayBuffer);
    const encodedImage = fileContent.toString("base64");
    logMessage(`Encoded: ${encodedImage.substring(0, 20)}...`);
    const processedContent = await vision_default(encodedImage, customPrompt, {
      baseUrl: this.settings.useCustomServer ? this.settings.customServerUrl : this.settings.defaultServerUrl,
      apiKey: this.settings.API_KEY
    });
    return processedContent;
  }
  async ensureFolderExists(folderPath) {
    if (!await this.app.vault.adapter.exists(folderPath)) {
      await this.app.vault.createFolder(folderPath);
    }
  }
  async checkAndCreateFolders() {
    this.ensureFolderExists(this.settings.pathToWatch);
    this.ensureFolderExists(this.settings.defaultDestinationPath);
    this.ensureFolderExists(this.settings.attachmentsPath);
    this.ensureFolderExists(this.settings.logFolderPath);
  }
  async getBacklog() {
    const allFiles = this.app.vault.getFiles();
    const pendingFiles = allFiles.filter(
      (file) => file.path.includes(this.settings.pathToWatch)
    );
    return pendingFiles;
  }
  async processBacklog() {
    const pendingFiles = await this.getBacklog();
    for (const file of pendingFiles) {
      await this.processFileV2(file);
    }
  }
  async getSimilarTags(content, fileName) {
    const tags = this.app.metadataCache.getTags();
    if (Object.keys(tags).length === 0) {
      logMessage("No tags found");
      return [];
    }
    logMessage("tags", tags);
    const tagNames = Object.keys(tags);
    const uniqueTags = [...new Set(tagNames)];
    logMessage("uniqueTags", uniqueTags);
    const prompt = `Given the text "${content}" (and if relevant ${fileName}), which of the following tags are the most relevant? ${uniqueTags.join(
      ", "
    )}`;
    const mostSimilarTags = await text_default(
      prompt,
      "Always answer with a list of tag names from the provided list. If none of the tags are relevant, answer with an empty list.",
      {
        baseUrl: this.settings.useCustomServer ? this.settings.customServerUrl : this.settings.defaultServerUrl,
        apiKey: this.settings.API_KEY
      }
    );
    logMessage("mostSimilarTags", mostSimilarTags);
    logMessage("content", content);
    const normalizedTags = mostSimilarTags.replace(/[^a-zA-Z0-9# ]/g, "").split(" ").map((tag) => tag.startsWith("#") ? tag : `#${tag}`).map((tag) => tag.trim()).filter((tag) => !content.includes(tag)).filter(async (tag) => {
      const frontMatterRegex = new RegExp(
        `^tags:\\s*\\[.*?${tag.slice(1)}.*?\\]`,
        "m"
      );
      const inlineTagRegex = new RegExp(`\\s${tag}(\\s|$)`);
      return !frontMatterRegex.test(content) && !inlineTagRegex.test(content);
    });
    logMessage("normalizedTags", normalizedTags);
    return normalizedTags;
  }
  isTFolder(file) {
    return file instanceof import_obsidian7.TFolder;
  }
  getAllFolders() {
    const allFiles = this.app.vault.getAllLoadedFiles();
    const folderPaths = allFiles.filter((file) => this.isTFolder(file)).map((folder) => folder.path);
    const uniqueFolders = [...new Set(folderPaths)];
    logMessage("uniqueFolders", uniqueFolders);
    return uniqueFolders;
  }
  async getAIClassifiedFolder(content, file) {
    let destinationFolder = "None";
    const uniqueFolders = this.getAllFolders().filter((folder) => {
      var _a;
      return folder !== ((_a = file.parent) == null ? void 0 : _a.path);
    }).filter((folder) => folder !== this.settings.defaultDestinationPath).filter((folder) => folder !== this.settings.attachmentsPath).filter((folder) => folder !== this.settings.logFolderPath).filter((folder) => folder !== this.settings.pathToWatch);
    logMessage("uniqueFolders", uniqueFolders);
    const mostSimilarFolder = await text_default(
      `Given the text content "${content}" (and if the file name "${file.basename}"), which of the following folders would be the most appropriate location for the file? Available folders: ${uniqueFolders.join(
        ", "
      )}`,
      "Please respond with the name of the most appropriate folder from the provided list. If none of the folders are suitable, respond with 'None'.",
      {
        baseUrl: this.settings.useCustomServer ? this.settings.customServerUrl : this.settings.defaultServerUrl,
        apiKey: this.settings.API_KEY
      }
    );
    logMessage("mostSimilarFolder", mostSimilarFolder);
    new import_obsidian7.Notice(`Most similar folder: ${mostSimilarFolder}`, 3e3);
    const sanitizedFolderName = mostSimilarFolder.replace(/[\\:*?"<>|]/g, "");
    if (sanitizedFolderName === "None") {
      destinationFolder = this.settings.defaultDestinationPath;
    }
    if (sanitizedFolderName !== "None") {
      destinationFolder = sanitizedFolderName;
    }
    return destinationFolder;
  }
  async appendTag(file, tag) {
    if (this.settings.useSimilarTagsInFrontmatter) {
      await this.appendToFrontMatter(file, "tags", tag);
      return;
    }
    await this.app.vault.append(file, `
${tag}`);
  }
  async appendSimilarTags(content, file) {
    if (!this.settings.useSimilarTags) {
      return;
    }
    const similarTags = await this.getSimilarTags(content, file.basename);
    if (similarTags.length === 0) {
      new import_obsidian7.Notice(`No similar tags found`, 3e3);
      return;
    }
    similarTags.forEach(async (tag) => {
      await this.appendTag(file, tag);
    });
    await this.appendToCustomLogFile(
      `Added similar tags to [[${file.basename}]]`
    );
    new import_obsidian7.Notice(`Added similar tags to ${file.basename}`, 3e3);
    return;
  }
  async getMostSimilarFileByName(content, currentFile) {
    const allMarkdownFiles = this.app.vault.getMarkdownFiles();
    const allMarkdownFilePaths = allMarkdownFiles.filter((file2) => file2.path !== currentFile.path).map((file2) => file2.path);
    const mostSimilarFile = await text_default(
      `Given the request of the user to append it in a certain file in "${content}", which of the following files would match the user request the most? Available files: ${allMarkdownFilePaths.join(
        ","
      )}`,
      "Please only respond with the full path of the most appropriate file from the provided list.",
      {
        baseUrl: this.settings.useCustomServer ? this.settings.customServerUrl : this.settings.defaultServerUrl,
        apiKey: this.settings.API_KEY
      }
    );
    const sanitizedFileName = mostSimilarFile.replace(/[\\:*?"<>|]/g, "");
    const file = this.app.vault.getAbstractFileByPath(sanitizedFileName);
    if (!file) {
      throw new Error(`Could not find file with path ${sanitizedFileName}`);
    }
    if (!(file instanceof import_obsidian7.TFile)) {
      throw new Error(
        `File with path ${sanitizedFileName} is not a markdown file`
      );
    }
    return file;
  }
  async appendToCustomLogFile(contentToAppend, action = "") {
    if (!this.settings.useLogs) {
      return;
    }
    const now = new Date();
    const formattedDate = (0, import_obsidian7.moment)(now).format("YYYY-MM-DD");
    const logFilePath = `${this.settings.logFolderPath}/${formattedDate}.md`;
    let logFile = this.app.vault.getAbstractFileByPath(logFilePath);
    if (!logFile) {
      logFile = await this.app.vault.create(logFilePath, "");
    }
    if (!(logFile instanceof import_obsidian7.TFile)) {
      throw new Error(`File with path ${logFilePath} is not a markdown file`);
    }
    const formattedTime = now.getHours().toString().padStart(2, "0") + ":" + now.getMinutes().toString().padStart(2, "0");
    const contentWithLink = `
 - ${formattedTime} ${contentToAppend}`;
    await this.app.vault.append(logFile, contentWithLink);
  }
  validateAPIKey() {
    if (this.settings.useCustomServer) {
      return true;
    }
    if (!this.settings.API_KEY) {
      throw new Error(
        "Please enter your API Key in the settings of the FileOrganizer plugin."
      );
    }
  }
  async appendToSimilarFile(incomingFile) {
    try {
      new import_obsidian7.Notice(`Processing incoming file ${incomingFile.basename}`, 3e3);
      const content = await this.getTextFromFile(incomingFile);
      const similarFile = await this.getMostSimilarFileByName(
        content,
        incomingFile
      );
      if (similarFile) {
        await this.app.vault.append(similarFile, `
${content}`);
        new import_obsidian7.Notice(
          `Appended content to similar file: ${similarFile.basename}`,
          3e3
        );
        this.appendToCustomLogFile(
          `Appended content from [[${incomingFile.basename}]] to similar file [[${similarFile.basename}]]`
        );
      } else {
        new import_obsidian7.Notice(`No similar file found for ${incomingFile.basename}`, 3e3);
      }
    } catch (error) {
      console.error("Error appending to similar file:", error);
      new import_obsidian7.Notice("Error processing incoming file.");
    }
  }
  // native
  async onload() {
    await this.initializePlugin();
    this.addCommand({
      id: "append-existing-tags",
      name: "Append existing tags",
      callback: async () => {
        const activeFile = this.app.workspace.getActiveFile();
        if (activeFile) {
          const fileContent = await this.getTextFromFile(activeFile);
          await this.appendSimilarTags(fileContent, activeFile);
        }
      }
    });
    this.addCommand({
      id: "show-assistant",
      name: "Show Assistant",
      callback: async () => {
        await this.showAssistantSidebar();
      }
    });
    this.addCommand({
      id: "add-to-inbox",
      name: "Put in inbox",
      callback: async () => {
        const activeFile = this.app.workspace.getActiveFile();
        if (activeFile) {
          await this.processFileV2(activeFile);
        }
      }
    });
    this.addCommand({
      id: "organize-text-file",
      name: "Organize text file",
      callback: async () => {
        const activeFile = this.app.workspace.getActiveFile();
        if (activeFile) {
          const fileContent = await this.getTextFromFile(activeFile);
          await this.organizeFile(activeFile, fileContent);
        }
      }
    });
    this.addCommand({
      id: "append-to-similar-file",
      name: "Append to similar file",
      callback: async () => {
        const activeFile = this.app.workspace.getActiveFile();
        if (activeFile) {
          await this.appendToSimilarFile(activeFile);
        }
      }
    });
    this.app.workspace.onLayoutReady(this.registerEventHandlers.bind(this));
    this.processBacklog();
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      new FileOrganizerSettings(),
      await this.loadData()
    );
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async initializePlugin() {
    await this.loadSettings();
    this.ensureFolderExists(this.settings.pathToWatch);
    this.addSettingTab(new FileOrganizerSettingTab(this.app, this));
    this.registerView(
      ASSISTANT_VIEW_TYPE,
      (leaf) => new AssistantView(leaf, this)
    );
  }
  registerEventHandlers() {
    this.registerEvent(
      this.app.vault.on("create", (file) => {
        if (!file.path.includes(this.settings.pathToWatch))
          return;
        if (file instanceof import_obsidian7.TFile) {
          this.processFileV2(file);
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("rename", (file) => {
        if (!file.path.includes(this.settings.pathToWatch))
          return;
        if (file instanceof import_obsidian7.TFile) {
          this.processFileV2(file);
        }
      })
    );
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
