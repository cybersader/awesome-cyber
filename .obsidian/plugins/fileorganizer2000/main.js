/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  default: () => FileOrganizer
});
module.exports = __toCommonJS(src_exports);
var import_obsidian7 = require("obsidian");

// src/modules/name.ts
var import_obsidian = require("obsidian");

// utils.ts
function formatToSafeName(format) {
  return format.replace(/[\\/:"]/g, "");
}
function cleanPath(path) {
  const trimmedPath = path.trim();
  const pathWithoutLeadingAndTrailingSlashes = trimmedPath.replace(
    /^\/+|\/+$/g,
    ""
  );
  return pathWithoutLeadingAndTrailingSlashes;
}
var logMessage = (...args) => {
  if (true) {
    return;
  }
  console.log(...args);
};

// src/modules/name.ts
async function useName(document2, { baseUrl, apiKey }) {
  const data = {
    messages: [
      {
        role: "system",
        content: "You are a helpful assistant. You only answer short (less than 30 chars titles). You do not use any special character just text. Use something very specific to the content not a generic title."
      },
      {
        role: "user",
        content: "Give a title to this document: \n " + document2
      }
    ]
  };
  const endpoint = "api/name";
  const url = `${baseUrl}/${endpoint}`;
  const response = await (0, import_obsidian.requestUrl)({
    url,
    method: "POST",
    body: JSON.stringify(data),
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${apiKey}`
    }
  });
  const result = await response.json;
  logMessage(result.choices[0].message.content);
  return result.choices[0].message.content.trim();
}
var name_default = useName;

// src/modules/vision.ts
var import_obsidian2 = require("obsidian");
var defaultPrompt = `Extract text from image. Write in markdown. If there's a drawing, describe it.`;
async function useVision(encodedImage, systemPrompt = defaultPrompt, { baseUrl, apiKey }) {
  const jsonPayload = {
    max_tokens: 800,
    messages: [
      {
        role: "user",
        content: [
          {
            type: "text",
            text: systemPrompt
          },
          {
            type: "image_url",
            image_url: {
              url: `data:image/jpeg;base64,${encodedImage}`
            }
          }
        ]
      }
    ]
  };
  const endpoint = "api/vision";
  const sanitizedBaseUrl = baseUrl.endsWith("/") ? baseUrl.slice(0, -1) : baseUrl;
  const url = `${sanitizedBaseUrl}/${endpoint}`;
  const response = await (0, import_obsidian2.requestUrl)({
    url,
    method: "POST",
    body: JSON.stringify(jsonPayload),
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${apiKey}`
    }
  });
  const result = await response.json;
  return result.choices[0].message.content;
}
var vision_default = useVision;

// src/modules/audio.ts
var import_obsidian3 = require("obsidian");
async function useAudio(audioFileBase64, { baseUrl, apiKey }) {
  const endpoint = "api/audio";
  const url = `${baseUrl}/${endpoint}`;
  try {
    const result = await (0, import_obsidian3.requestUrl)({
      url,
      method: "POST",
      body: JSON.stringify({ file: audioFileBase64 }),
      headers: {
        Authorization: "Bearer " + apiKey,
        "Content-Type": "application/json"
      }
    });
    const data = await result.json;
    logMessage(data.text);
    return data.text;
  } catch (error) {
    console.error("Error uploading audio file:", error);
  }
}
var audio_default = useAudio;

// src/modules/text.ts
var import_obsidian4 = require("obsidian");
async function useText(content, systemPrompt, { baseUrl, apiKey }) {
  const data = {
    temperature: 0,
    messages: [
      {
        role: "system",
        content: systemPrompt
      },
      {
        role: "user",
        content
      }
    ]
  };
  const endpoint = "api/text";
  const url = `${baseUrl}/${endpoint}`;
  const response = await (0, import_obsidian4.requestUrl)({
    url,
    method: "POST",
    body: JSON.stringify(data),
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${apiKey}`
    }
  });
  const result = await response.json;
  logMessage(result);
  logMessage(result.choices[0].message.content);
  return result.choices[0].message.content.trim();
}
var text_default = useText;

// src/FileOrganizerSettingTab.ts
var import_obsidian5 = require("obsidian");
var FileOrganizerSettingTab = class extends import_obsidian5.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian5.Setting(containerEl).setName("File Organizer API Key").setDesc(
      "Enter your API Key here. Get it at https://app.fileorganizer2000.com/ "
    ).addText(
      (text) => text.setPlaceholder("Enter your API Key").setValue(this.plugin.settings.API_KEY).onChange(async (value) => {
        if (value)
          loginButton.settingEl.hide();
        if (!value)
          loginButton.settingEl.show();
        this.plugin.settings.API_KEY = value;
        await this.plugin.saveSettings();
      })
    );
    const loginButton = new import_obsidian5.Setting(containerEl).setName("Login").setDesc("Click to login to File Organizer 2000").addButton(
      (button) => button.setButtonText("Login").onClick(() => {
        window.open("https://app.fileorganizer2000.com/", "_blank");
      })
    );
    loginButton.settingEl.hide();
    new import_obsidian5.Setting(containerEl).setName("Inbox folder").setDesc("Choose which folder to automatically organize files from").addText(
      (text) => text.setPlaceholder("Enter your path").setValue(this.plugin.settings.pathToWatch).onChange(async (value) => {
        this.plugin.settings.pathToWatch = cleanPath(value);
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian5.Setting(containerEl).setName("Features").setHeading();
    new import_obsidian5.Setting(containerEl).setName("FileOrganizer logs").setDesc(
      "Allows you to keep track of the changes made by file Organizer."
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.useLogs).onChange(async (value) => {
        this.plugin.settings.useLogs = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian5.Setting(containerEl).setName("Similar tags").setDesc("Append similar tags to processed files.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.useSimilarTags).onChange(async (value) => {
        this.plugin.settings.useSimilarTags = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian5.Setting(containerEl).setName("Add similar tags in frontmatter").setDesc("Use frontmatter to add similar tags to processed files.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.useSimilarTagsInFrontmatter).onChange(async (value) => {
        this.plugin.settings.useSimilarTagsInFrontmatter = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian5.Setting(containerEl).setName("Rename document title").setDesc("Rename the document title based on the content.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.renameDocumentTitle).onChange(async (value) => {
        this.plugin.settings.renameDocumentTitle = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian5.Setting(containerEl).setName("Aliases").setDesc("Append aliases to processed files.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.useAliases).onChange(async (value) => {
        this.plugin.settings.useAliases = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian5.Setting(containerEl).setName("Processed File Tag").setDesc("Specify the tag to be added to processed files.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.processedTag).onChange(async (value) => {
        this.plugin.settings.processedTag = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian5.Setting(containerEl).setName("Folder config").setHeading();
    new import_obsidian5.Setting(containerEl).setName("Attachments folder").setDesc(
      "Enter the path to the folder where the original images and audio will be moved."
    ).addText(
      (text) => text.setPlaceholder("Enter your path").setValue(this.plugin.settings.attachmentsPath).onChange(async (value) => {
        this.plugin.settings.attachmentsPath = cleanPath(value);
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian5.Setting(containerEl).setName("File Organizer log folder").setDesc("Choose a folder for Organization Logs e.g. Ava/Logs.").addText(
      (text) => text.setPlaceholder("Enter your path").setValue(this.plugin.settings.logFolderPath).onChange(async (value) => {
        this.plugin.settings.logFolderPath = cleanPath(value);
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian5.Setting(containerEl).setName("Output folder path").setDesc(
      "Enter the path where you want to save the processed files. e.g. Processed/myfavoritefolder"
    ).addText(
      (text) => text.setPlaceholder("Enter your path").setValue(this.plugin.settings.defaultDestinationPath).onChange(async (value) => {
        const cleanedPath = cleanPath(value);
        logMessage(cleanedPath);
        this.plugin.settings.defaultDestinationPath = cleanedPath;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian5.Setting(containerEl).setName("Experimental features").setHeading();
    new import_obsidian5.ButtonComponent(containerEl).setButtonText("Become an Early Supporter").setCta().onClick(() => {
      window.open("https://app.fileorganizer2000.com/", "_blank");
    });
    new import_obsidian5.Setting(containerEl).setName("Enable Early Access").setDesc(
      "Enable early access to new features. You need to be a supporter to enable this."
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enableEarlyAccess).onChange(async (value) => {
        new import_obsidian5.Notice("Checking for early access...");
        if (!value) {
          this.plugin.settings.enableEarlyAccess = false;
          await this.plugin.saveSettings();
          return;
        }
        const isCustomer = await this.plugin.checkForEarlyAccess();
        if (!isCustomer) {
          new import_obsidian5.Notice(
            "You need to be a supporter to enable Early Access Features.",
            6e3
          );
          toggle.setValue(false);
          return;
        }
        this.plugin.settings.enableEarlyAccess = true;
        new import_obsidian5.Notice("Early Access Features enabled.");
        return;
      })
    );
    new import_obsidian5.Setting(containerEl).setName("Use Self-hosted").setDesc("Toggle to use a custom server instead of the default.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.useCustomServer).onChange(async (value) => {
        this.plugin.settings.useCustomServer = value;
        await this.plugin.saveSettings();
        if (!value) {
          customServerSetting.settingEl.hide();
          return;
        }
        customServerSetting.settingEl.show();
      })
    );
    const customServerSetting = new import_obsidian5.Setting(containerEl).setName("Self-hosted URL").setDesc("Enter the address of your custom server.").addText(
      (text) => text.setPlaceholder("http://localhost:3000").setValue(this.plugin.settings.customServerUrl).onChange(async (value) => {
        this.plugin.settings.customServerUrl = value;
        await this.plugin.saveSettings();
      })
    );
    customServerSetting.settingEl.hide();
    if (this.plugin.settings.useCustomServer) {
      customServerSetting.settingEl.show();
    }
    if (!this.plugin.settings.API_KEY) {
      loginButton.settingEl.show();
    }
    new import_obsidian5.Setting(containerEl).setName("AI Assistant (available in early access)").setDesc(
      "A sidebar that gives you more control in your file management."
    );
    new import_obsidian5.Setting(containerEl).setName("Experimental: Describe workflow (in progress)").setDesc(
      "Use words to explain how File Organizer uses GPT-4 to organize your files."
    ).setDisabled(true);
    new import_obsidian5.Setting(containerEl).setName("Experimental: Full Auto Org (in progress)").setDesc("Let file Organizer work fully automatically.").setDisabled(true);
    new import_obsidian5.Setting(containerEl).setName("Custom Formatting (early access only works for supporters)").setHeading();
    new import_obsidian5.Setting(containerEl).setName("Document Type Configuration").setDesc(
      "To specify the document type for AI formatting, please add a file inside the template folder of File Organizer. Each file should be named according to the document type it represents (e.g., 'workout'). The content of each file should be the prompt that will be applied to the formatting. Additionally, you can access and manage these document types directly through the AI sidebar in the application."
    ).setDisabled(true);
  }
};

// src/AssistantView.ts
var import_obsidian6 = require("obsidian");
var ASSISTANT_VIEW_TYPE = "fo2k.assistant.sidebar";
var AssistantView = class extends import_obsidian6.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.displayTitle = async (file) => {
      const title = file.basename;
      this.selectedFileBox.empty();
      const titleElement = this.selectedFileBox.createEl("span", { text: title });
      titleElement.style.fontSize = "1rem";
      this.selectedFileBox.appendChild(titleElement);
    };
    this.suggestTags = async (file, content) => {
      const tags = await this.plugin.getSimilarTags(content, file.basename);
      if (tags.length > 0) {
        this.suggestionBox.empty();
        tags.forEach((tag) => {
          const child = this.suggestionBox.appendChild(
            this.suggestionBox.createEl("span", {
              cls: [
                "cursor-pointer",
                "cm-hashtag",
                "cm-hashtag-begin",
                "cm-meta",
                "cm-tag",
                "cm-hashtag-end"
              ],
              text: tag
            })
          );
          child.style.cursor = "pointer";
          child.style.margin = "2px";
          if (tags.indexOf(tag) === 0) {
            child.style.margin = "0px";
          }
          child.style.fontSize = "1rem";
          child.addEventListener("click", () => {
            if (!tag.startsWith("#")) {
              tag = `#${tag}`;
            }
            this.plugin.appendTag(file, tag);
            child.remove();
          });
        });
      } else {
        this.suggestionBox.setText("No suggestions");
        this.suggestionBox.style.color = "var(--text-accent)";
      }
      this.loading.style.display = "none";
    };
    this.suggestAlias = async (file, content) => {
      const suggestedName = await this.plugin.generateNameFromContent(content);
      this.aliasSuggestionBox.empty();
      this.aliasSuggestionBox.style.display = "flex";
      this.aliasSuggestionBox.style.alignItems = "center";
      const nameElement = this.aliasSuggestionBox.createEl("span", {
        text: suggestedName
      });
      const renameIcon = this.aliasSuggestionBox.createEl("span", {
        cls: ["clickable-icon", "setting-editor-extra-setting-button"]
      });
      (0, import_obsidian6.setIcon)(renameIcon, "plus");
      renameIcon.style.cursor = "pointer";
      renameIcon.style.margin = "5px";
      renameIcon.onclick = async () => {
        logMessage("Adding alias " + suggestedName + " to " + file.basename);
        this.plugin.appendToFrontMatter(file, "alias", suggestedName);
      };
      nameElement.style.fontSize = "1rem";
      nameElement.style.color = "var(--text-accent)";
      this.aliasSuggestionBox.appendChild(nameElement);
      this.aliasSuggestionBox.appendChild(renameIcon);
    };
    this.suggestFolders = async (file, content) => {
      const folder = await this.plugin.getAIClassifiedFolder(content, file);
      this.similarFolderBox.empty();
      this.similarFolderBox.style.display = "flex";
      this.similarFolderBox.style.alignItems = "center";
      this.similarFolderBox.appendChild(
        this.similarFolderBox.createEl("span", { text: folder })
      );
      const moveFilebutton = this.similarFolderBox.createEl("div", {
        text: "Move",
        cls: ["clickable-icon", "setting-editor-extra-setting-button"]
      });
      (0, import_obsidian6.setIcon)(moveFilebutton, "folder-input");
      moveFilebutton.style.cursor = "pointer";
      moveFilebutton.style.margin = "5px";
      moveFilebutton.onclick = () => {
        this.plugin.moveContent(file, file.basename, folder);
      };
      this.similarFolderBox.style.fontSize = "1rem";
      this.similarFolderBox.style.color = "var(--text-accent)";
      this.similarFolderBox.appendChild(moveFilebutton);
    };
    this.handleFileOpen = async (file) => {
      this.containerEl.empty();
      this.initUI();
      if (!this.plugin.settings.enableEarlyAccess) {
        return;
      }
      this.loading.style.display = "block";
      if (!file) {
        this.suggestionBox.setText("No file opened");
        this.loading.style.display = "none";
        return;
      }
      if (!file.extension.includes("md")) {
        this.containerEl.empty();
        this.containerEl.createEl("h5", {
          text: "The AI Assistant only works with markdown files."
        });
        this.loading.style.display = "none";
        return;
      }
      const aiAssistantSidebar = document.querySelector(
        ".assistant-container"
      );
      if (aiAssistantSidebar) {
        aiAssistantSidebar.style.display = "none";
      }
      this.displayTitle(file);
      const content = await this.plugin.getTextFromFile(file);
      this.suggestTags(file, content);
      this.suggestFolders(file, content);
      await this.suggestAlias(file, content);
      await this.displayClassification(file, content);
      if (aiAssistantSidebar) {
        aiAssistantSidebar.style.display = "";
      }
    };
    this.createHeader = (text) => {
      const header = this.containerEl.createEl("h6", { text });
      header.style.paddingLeft = "24px";
      return header;
    };
    this.plugin = plugin;
  }
  getDisplayText() {
    return "Assistant";
  }
  getViewType() {
    return ASSISTANT_VIEW_TYPE;
  }
  getIcon() {
    return "pencil";
  }
  async displayClassification(file, content) {
    logMessage("Checking document type");
    const classification = await this.plugin.useCustomClassifier(
      content,
      file.basename
    );
    logMessage("Current document type: " + (classification == null ? void 0 : classification.type));
    this.classificationBox.empty();
    this.classificationBox.style.display = "flex";
    this.classificationBox.style.alignItems = "center";
    const typeElement = this.classificationBox.createEl("span", {
      text: classification == null ? void 0 : classification.type
    });
    typeElement.style.fontSize = "1rem";
    if (classification) {
      new import_obsidian6.ButtonComponent(this.classificationBox).setButtonText("Change").onClick(async () => {
        await this.plugin.formatContent(file, content, classification);
      });
    }
  }
  initUI() {
    this.containerEl.empty();
    this.containerEl.addClass("assistant-container");
    if (!this.plugin.settings.enableEarlyAccess) {
      this.containerEl.createEl("h5", {
        text: "The AI Assistant is an early access feature currently available to supporters."
      });
      const supportLink = this.containerEl.createEl("a", {
        href: "https://dub.sh/support-fo2k",
        text: "Support here to gain access."
      });
      supportLink.setAttr("target", "_blank");
    }
    this.createHeader("Looking at");
    this.selectedFileBox = this.containerEl.createEl("div");
    this.selectedFileBox.style.paddingLeft = "24px";
    this.createHeader("Similar tags");
    this.suggestionBox = this.containerEl.createEl("div");
    this.suggestionBox.style.paddingLeft = "24px";
    this.createHeader("Suggested alias");
    this.aliasSuggestionBox = this.containerEl.createEl("div");
    this.aliasSuggestionBox.style.paddingLeft = "24px";
    this.createHeader("Suggested folder");
    this.similarFolderBox = this.containerEl.createEl("div");
    this.similarFolderBox.style.paddingLeft = "24px";
    this.createHeader("Looks like a");
    this.classificationBox = this.containerEl.createEl("div");
    this.classificationBox.style.paddingLeft = "24px";
    this.loading = this.suggestionBox.createEl("div", {
      text: "Loading..."
    });
    this.loading.style.display = "none";
  }
  async onOpen() {
    this.containerEl.empty();
    this.containerEl.addClass("assistant-container");
    this.handleFileOpen(this.app.workspace.getActiveFile());
    this.initUI();
    this.fileOpenEventRef = this.app.workspace.on("file-open", async (file) => {
      this.handleFileOpen(file);
    });
    this.registerEvent(this.fileOpenEventRef);
  }
  async onClose() {
    if (this.fileOpenEventRef) {
      this.app.workspace.offref(this.fileOpenEventRef);
    }
  }
};

// src/index.ts
var FileOrganizerSettings = class {
  constructor() {
    this.API_KEY = "";
    this.useLogs = true;
    this.defaultDestinationPath = "_FileOrganizer2000/Processed";
    this.attachmentsPath = "_FileOrganizer2000/Processed/Attachments";
    this.pathToWatch = "_FileOrganizer2000/Inbox";
    this.logFolderPath = "_FileOrganizer2000/Logs";
    this.useSimilarTags = true;
    // default value is true
    this.renameDocumentTitle = true;
    // default value is true
    this.useAliases = false;
    // default value is false
    this.useAutoAppend = false;
    this.defaultServerUrl = "https://app.fileorganizer2000.com";
    this.customServerUrl = "https://file-organizer-2000.vercel.app/";
    this.useCustomServer = false;
    this.useSimilarTagsInFrontmatter = false;
    this.enableEarlyAccess = false;
    this.earlyAccessCode = "";
    this.processedTag = false;
    // new formatting
    this.templatePaths = "_FileOrganizer2000/Templates";
  }
};
var validAudioExtensions = ["mp3", "wav", "webm", "m4a"];
var validImageExtensions = ["png", "jpg", "jpeg", "gif", "svg", "webp"];
var validMediaExtensions = [...validAudioExtensions, ...validImageExtensions];
var validTextExtensions = ["md", "txt"];
var validExtensions = [...validMediaExtensions, ...validTextExtensions];
var isValidExtension = (extension) => {
  if (!validExtensions.includes(extension)) {
    new import_obsidian7.Notice("Sorry, FileOrganizer does not support this file type.");
    return false;
  }
  return true;
};
var FileOrganizer = class extends import_obsidian7.Plugin {
  // all files in inbox will go through this function
  async processFileV2(originalFile) {
    try {
      new import_obsidian7.Notice(`Looking at ${originalFile.basename}`, 3e3);
      this.validateAPIKey();
      if (!originalFile.extension || !isValidExtension(originalFile.extension))
        return;
      await this.checkAndCreateFolders();
      const text = await this.getTextFromFile(originalFile);
      const isRenameEnabled = this.settings.renameDocumentTitle;
      if (isRenameEnabled) {
        new import_obsidian7.Notice(`Generating name for ${text.substring(0, 20)}...`, 3e3);
      }
      const humanReadableFileName = isRenameEnabled ? await this.generateNameFromContent(text) : originalFile.basename;
      if (isRenameEnabled) {
        new import_obsidian7.Notice(`Generated name: ${humanReadableFileName}`, 3e3);
      }
      if (validMediaExtensions.includes(originalFile.extension)) {
        const annotatedFile = await this.createFileFromContent(text);
        this.appendToCustomLogFile(
          `Generated annotation for [[${annotatedFile.basename}]]`
        );
        await this.moveToDefaultAttachmentFolder(
          originalFile,
          humanReadableFileName
        );
        await this.appendAttachment(annotatedFile, originalFile);
        await this.renameTagAndOrganize(
          annotatedFile,
          text,
          humanReadableFileName
        );
        await this.tagAsProcessed(annotatedFile);
      } else {
        await this.renameTagAndOrganize(
          originalFile,
          text,
          humanReadableFileName
        );
        await this.tagAsProcessed(originalFile);
      }
    } catch (e) {
      new import_obsidian7.Notice(
        `Error processing ${originalFile.basename}: ${e.message}`,
        3e3
      );
    }
  }
  // we use this to keep track if we have already processed a file vs not
  // to indicate it to our users (aka they won't need to send it to inbox again)
  async tagAsProcessed(file) {
    if (!this.settings.processedTag) {
      return;
    }
    const tag = "#fo2k";
    this.appendTag(file, tag);
  }
  async getClassifications() {
    const templateFolder = this.app.vault.getAbstractFileByPath(
      this.settings.templatePaths
    );
    if (!templateFolder || !(templateFolder instanceof import_obsidian7.TFolder)) {
      console.error("Template folder not found or is not a valid folder.");
      return [];
    }
    const templateFiles = templateFolder.children.filter(
      (file) => file instanceof import_obsidian7.TFile
    );
    const classifications = await Promise.all(
      templateFiles.map(async (file) => ({
        type: file.basename,
        formattingInstruction: await this.app.vault.read(file)
      }))
    );
    return classifications;
  }
  async useCustomClassifier(content, name) {
    const classifications = await this.getClassifications();
    logMessage("classifications", classifications);
    const prompt = `Name: ${name}
  Content:
  ${content}
  classifications:${classifications.map((c) => c.type).join(", ")}
Which of the following classifications would 
  be the most appropriate for the given content?`;
    const whatTypeOfDocument = await text_default(
      prompt,
      "Please respond with the name of the most appropriate classification from the provided list. If none of the classifications are suitable, respond with 'None'.",
      {
        baseUrl: this.settings.useCustomServer ? this.settings.customServerUrl : this.settings.defaultServerUrl,
        apiKey: this.settings.API_KEY
      }
    );
    logMessage("whatTypeOfDocument", whatTypeOfDocument);
    const selectedClassification = classifications.find(
      (c) => c.type.toLowerCase() === whatTypeOfDocument.toLowerCase()
    );
    return selectedClassification || null;
  }
  async formatContent(file, fileContent, selectedClassification) {
    const formattedContent = await text_default(
      fileContent,
      selectedClassification.formattingInstruction,
      {
        baseUrl: this.settings.useCustomServer ? this.settings.customServerUrl : this.settings.defaultServerUrl,
        apiKey: this.settings.API_KEY
      }
    );
    await this.app.vault.modify(file, formattedContent);
  }
  /* experimental above until further notice */
  async organizeFile(file, content) {
    const destinationFolder = await this.getAIClassifiedFolder(content, file);
    new import_obsidian7.Notice(`Most similar folder: ${destinationFolder}`, 3e3);
    await this.moveContent(file, file.basename, destinationFolder);
  }
  async renameTagAndOrganize(file, content, fileName) {
    const destinationFolder = await this.getAIClassifiedFolder(content, file);
    new import_obsidian7.Notice(`Most similar folder: ${destinationFolder}`, 3e3);
    await this.appendAlias(file, file.basename);
    await this.moveContent(file, fileName, destinationFolder);
    await this.appendSimilarTags(content, file);
  }
  async createBackup(file) {
    const destinationFolder = this.settings.defaultDestinationPath;
    const destinationPath = `${destinationFolder}/${file.name}`;
    await this.app.vault.copy(file, destinationPath);
    this.appendToCustomLogFile(
      `Backed Up [[${file.name}]] to ${destinationPath}`
    );
  }
  async showAssistantSidebar() {
    this.app.workspace.detachLeavesOfType(ASSISTANT_VIEW_TYPE);
    await this.app.workspace.getRightLeaf(false).setViewState({
      type: ASSISTANT_VIEW_TYPE,
      active: true
    });
    this.app.workspace.revealLeaf(
      this.app.workspace.getLeavesOfType(ASSISTANT_VIEW_TYPE)[0]
    );
  }
  async getTextFromFile(file) {
    let content = "";
    if (file.extension === "md") {
      content = await this.app.vault.read(file);
    } else if (validImageExtensions.includes(file.extension)) {
      content = await this.generateImageAnnotation(file);
    } else if (validAudioExtensions.includes(file.extension)) {
      content = await this.generateTranscriptFromAudio(file);
    }
    return content;
  }
  // adds an attachment to a file using the ![[attachment]] syntax
  async appendAttachment(processedFile, attachmentFile) {
    logMessage("Appending attachment", attachmentFile);
    await this.app.vault.append(processedFile, `![[${attachmentFile.name}]]`);
  }
  async appendToFrontMatter(file, key, value) {
    await this.app.fileManager.processFrontMatter(file, (frontmatter) => {
      if (!frontmatter.hasOwnProperty(key)) {
        frontmatter[key] = value;
        return;
      }
      if (!Array.isArray(frontmatter[key])) {
        frontmatter[key] = [frontmatter[key]];
      }
      frontmatter[key].push(value);
    });
  }
  async appendAlias(file, alias) {
    if (!this.settings.useAliases) {
      logMessage("Not appending aliases");
      return;
    }
    logMessage("Appending alias", alias);
    this.appendToFrontMatter(file, "alias", alias);
  }
  // creates a .md file with a humean readable name guessed from the content
  async createFileFromContent(content) {
    const now = new Date();
    const formattedNow = now.toISOString().replace(/[-:.TZ]/g, "");
    let name = formattedNow;
    try {
      name = await name_default(content, {
        baseUrl: this.settings.useCustomServer ? this.settings.customServerUrl : this.settings.defaultServerUrl,
        apiKey: this.settings.API_KEY
      });
    } catch (error) {
      console.error("Error processing file:", error.status);
      new import_obsidian7.Notice("Could not set a human readable name.");
    }
    const safeName = formatToSafeName(name);
    const outputFilePath = `/${this.settings.defaultDestinationPath}/${safeName}.md`;
    const file = await this.app.vault.create(outputFilePath, content);
    return file;
  }
  async moveContent(file, humanReadableFileName, destinationFolder = "") {
    new import_obsidian7.Notice(`Moving file to ${destinationFolder}`, 3e3);
    await this.app.vault.rename(
      file,
      `${destinationFolder}/${humanReadableFileName}.${file.extension}`
    );
    await this.appendToCustomLogFile(
      `Organized [[${humanReadableFileName}]] into ${destinationFolder}`
    );
    return file;
  }
  async moveToDefaultAttachmentFolder(file, newFileName) {
    const destinationFolder = this.settings.attachmentsPath;
    const destinationPath = `${destinationFolder}/${newFileName}.${file.extension}`;
    await this.app.vault.rename(file, destinationPath);
    await this.appendToCustomLogFile(
      `Moved [[${newFileName}.${file.extension}]] to attachments`
    );
  }
  async generateNameFromContent(content) {
    const name = await name_default(content, {
      baseUrl: this.settings.useCustomServer ? this.settings.customServerUrl : this.settings.defaultServerUrl,
      apiKey: this.settings.API_KEY
    });
    const safeName = formatToSafeName(name);
    return safeName;
  }
  async generateTranscriptFromAudio(file) {
    new import_obsidian7.Notice(`Generating transcription for ${file.basename}`, 3e3);
    const arrayBuffer = await this.app.vault.readBinary(file);
    const fileContent = Buffer.from(arrayBuffer);
    const encodedAudio = fileContent.toString("base64");
    logMessage(`Encoded: ${encodedAudio.substring(0, 20)}...`);
    const transcribedText = await audio_default(encodedAudio, {
      baseUrl: this.settings.useCustomServer ? this.settings.customServerUrl : this.settings.defaultServerUrl,
      apiKey: this.settings.API_KEY
    });
    const postProcessedText = transcribedText;
    return postProcessedText;
  }
  async generateImageAnnotation(file, customPrompt) {
    new import_obsidian7.Notice(`Generating annotation for ${file.basename}`, 3e3);
    const arrayBuffer = await this.app.vault.readBinary(file);
    const fileContent = Buffer.from(arrayBuffer);
    const encodedImage = fileContent.toString("base64");
    logMessage(`Encoded: ${encodedImage.substring(0, 20)}...`);
    const processedContent = await vision_default(encodedImage, customPrompt, {
      baseUrl: this.settings.useCustomServer ? this.settings.customServerUrl : this.settings.defaultServerUrl,
      apiKey: this.settings.API_KEY
    });
    return processedContent;
  }
  async ensureFolderExists(folderPath) {
    if (!await this.app.vault.adapter.exists(folderPath)) {
      await this.app.vault.createFolder(folderPath);
    }
  }
  async checkAndCreateFolders() {
    this.ensureFolderExists(this.settings.pathToWatch);
    this.ensureFolderExists(this.settings.defaultDestinationPath);
    this.ensureFolderExists(this.settings.attachmentsPath);
    this.ensureFolderExists(this.settings.logFolderPath);
    this.ensureFolderExists(this.settings.templatePaths);
  }
  async getBacklog() {
    const allFiles = this.app.vault.getFiles();
    const pendingFiles = allFiles.filter(
      (file) => file.path.includes(this.settings.pathToWatch)
    );
    return pendingFiles;
  }
  async processBacklog() {
    const pendingFiles = await this.getBacklog();
    for (const file of pendingFiles) {
      await this.processFileV2(file);
    }
  }
  async getSimilarTags(content, fileName) {
    const tags = this.app.metadataCache.getTags();
    if (Object.keys(tags).length === 0) {
      logMessage("No tags found");
      return [];
    }
    logMessage("tags", tags);
    const tagNames = Object.keys(tags);
    const uniqueTags = [...new Set(tagNames)];
    logMessage("uniqueTags", uniqueTags);
    const data = {
      content,
      fileName,
      tags: uniqueTags
    };
    const response = await (0, import_obsidian7.requestUrl)({
      url: `${this.settings.useCustomServer ? this.settings.customServerUrl : this.settings.defaultServerUrl}/api/tagging`,
      method: "POST",
      body: JSON.stringify(data),
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${this.settings.API_KEY}`
      }
    });
    const result = await response.json;
    console.log(result, "test");
    return result.tags;
  }
  isTFolder(file) {
    return file instanceof import_obsidian7.TFolder;
  }
  getAllFolders() {
    const allFiles = this.app.vault.getAllLoadedFiles();
    const folderPaths = allFiles.filter((file) => this.isTFolder(file)).map((folder) => folder.path);
    const uniqueFolders = [...new Set(folderPaths)];
    logMessage("uniqueFolders", uniqueFolders);
    return uniqueFolders;
  }
  async getAIClassifiedFolder(content, file) {
    let destinationFolder = "None";
    const uniqueFolders = this.getAllFolders().filter((folder) => {
      var _a;
      return folder !== ((_a = file.parent) == null ? void 0 : _a.path);
    }).filter((folder) => folder !== this.settings.defaultDestinationPath).filter((folder) => folder !== this.settings.attachmentsPath).filter((folder) => folder !== this.settings.logFolderPath).filter((folder) => folder !== this.settings.pathToWatch);
    logMessage("uniqueFolders", uniqueFolders);
    const data = {
      content,
      fileName: file.basename,
      folders: uniqueFolders
    };
    const response = await (0, import_obsidian7.requestUrl)({
      url: `${this.settings.useCustomServer ? this.settings.customServerUrl : this.settings.defaultServerUrl}/api/folders`,
      method: "POST",
      body: JSON.stringify(data),
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${this.settings.API_KEY}`
      }
    });
    const result = await response.json;
    const sanitizedFolderName = result.folder.replace(/[\\:*?"<>|]/g, "");
    if (sanitizedFolderName === "None") {
      destinationFolder = this.settings.defaultDestinationPath;
    }
    if (sanitizedFolderName !== "None") {
      destinationFolder = sanitizedFolderName;
    }
    return destinationFolder;
  }
  async appendTag(file, tag) {
    if (this.settings.useSimilarTagsInFrontmatter) {
      await this.appendToFrontMatter(file, "tags", tag);
      return;
    }
    await this.app.vault.append(file, `
${tag}`);
  }
  async appendSimilarTags(content, file) {
    if (!this.settings.useSimilarTags) {
      return;
    }
    const similarTags = await this.getSimilarTags(content, file.basename);
    if (similarTags.length === 0) {
      new import_obsidian7.Notice(`No similar tags found`, 3e3);
      return;
    }
    similarTags.forEach(async (tag) => {
      await this.appendTag(file, tag);
    });
    await this.appendToCustomLogFile(
      `Added similar tags to [[${file.basename}]]`
    );
    new import_obsidian7.Notice(`Added similar tags to ${file.basename}`, 3e3);
    return;
  }
  async appendToCustomLogFile(contentToAppend, action = "") {
    if (!this.settings.useLogs) {
      return;
    }
    const now = new Date();
    const formattedDate = (0, import_obsidian7.moment)(now).format("YYYY-MM-DD");
    const logFilePath = `${this.settings.logFolderPath}/${formattedDate}.md`;
    let logFile = this.app.vault.getAbstractFileByPath(logFilePath);
    if (!logFile) {
      logFile = await this.app.vault.create(logFilePath, "");
    }
    if (!(logFile instanceof import_obsidian7.TFile)) {
      throw new Error(`File with path ${logFilePath} is not a markdown file`);
    }
    const formattedTime = now.getHours().toString().padStart(2, "0") + ":" + now.getMinutes().toString().padStart(2, "0");
    const contentWithLink = `
 - ${formattedTime} ${contentToAppend}`;
    await this.app.vault.append(logFile, contentWithLink);
  }
  validateAPIKey() {
    if (this.settings.useCustomServer) {
      return true;
    }
    if (!this.settings.API_KEY) {
      throw new Error(
        "Please enter your API Key in the settings of the FileOrganizer plugin."
      );
    }
  }
  // native
  async onload() {
    await this.initializePlugin();
    this.addCommand({
      id: "append-existing-tags",
      name: "Append existing tags",
      callback: async () => {
        const activeFile = this.app.workspace.getActiveFile();
        if (activeFile) {
          const fileContent = await this.getTextFromFile(activeFile);
          await this.appendSimilarTags(fileContent, activeFile);
        }
      }
    });
    this.addCommand({
      id: "show-assistant",
      name: "Show Assistant",
      callback: async () => {
        if (!this.settings.enableEarlyAccess) {
          new import_obsidian7.Notice(
            "This feature is only available for early access supporters",
            3e3
          );
          return;
        }
        await this.showAssistantSidebar();
      }
    });
    this.addCommand({
      id: "add-to-inbox",
      name: "Put in inbox",
      callback: async () => {
        const activeFile = this.app.workspace.getActiveFile();
        if (activeFile) {
          await this.processFileV2(activeFile);
        }
      }
    });
    this.addCommand({
      id: "organize-text-file",
      name: "Organize text file",
      callback: async () => {
        const activeFile = this.app.workspace.getActiveFile();
        if (activeFile) {
          const fileContent = await this.getTextFromFile(activeFile);
          await this.organizeFile(activeFile, fileContent);
        }
      }
    });
    this.app.workspace.onLayoutReady(this.registerEventHandlers.bind(this));
    this.processBacklog();
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      new FileOrganizerSettings(),
      await this.loadData()
    );
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async initializePlugin() {
    await this.loadSettings();
    await this.checkAndCreateFolders();
    this.addSettingTab(new FileOrganizerSettingTab(this.app, this));
    this.registerView(
      ASSISTANT_VIEW_TYPE,
      (leaf) => new AssistantView(leaf, this)
    );
  }
  async checkForEarlyAccess() {
    try {
      const response = await (0, import_obsidian7.requestUrl)({
        url: `${this.settings.useCustomServer ? this.settings.customServerUrl : this.settings.defaultServerUrl}/api/early-access`,
        method: "POST",
        body: JSON.stringify({ code: this.settings.earlyAccessCode }),
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${this.settings.API_KEY}`
        }
      });
      const result = await response.json;
      return result.isCustomer;
    } catch (e) {
      new import_obsidian7.Notice("Error checking for early access", 3e3);
      console.error("Error checking for early access", e);
      return false;
    }
  }
  registerEventHandlers() {
    this.registerEvent(
      this.app.vault.on("create", (file) => {
        if (!file.path.includes(this.settings.pathToWatch))
          return;
        if (file instanceof import_obsidian7.TFile) {
          this.processFileV2(file);
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("rename", (file) => {
        if (!file.path.includes(this.settings.pathToWatch))
          return;
        if (file instanceof import_obsidian7.TFile) {
          this.processFileV2(file);
        }
      })
    );
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
